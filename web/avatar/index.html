<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Siraj 3D Avatar</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #F8F5F0, #F1E9D9);
            font-family: 'Cairo', sans-serif;
            overflow: hidden;
        }
        
        #avatar-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #avatar-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #805B36;
            font-size: 18px;
            text-align: center;
        }
        
        .emotion-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(196, 164, 96, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="avatar-container">
        <canvas id="avatar-canvas"></canvas>
        <div class="loading" id="loading">Loading Siraj Avatar...</div>
        <div class="emotion-indicator" id="emotion-indicator" style="display: none;">ðŸ˜Š Happy</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        class SirajAvatar {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.avatar = null;
                this.mixer = null;
                this.animations = {};
                this.currentAnimation = null;
                this.currentEmotion = 'neutral';
                this.lipSyncData = null;
                this.lipSyncStartTime = 0;
                this.isPlaying = false;
                
                this.init();
            }

            init() {
                this.setupScene();
                this.setupLighting();
                this.loadAvatar();
                this.animate();
                this.setupMessageListener();
            }

            setupScene() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xF8F5F0);

                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 1.6, 3);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('avatar-canvas'),
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Controls
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.target.set(0, 1.6, 0);
                this.controls.maxDistance = 5;
                this.controls.minDistance = 1;

                // Handle resize
                window.addEventListener('resize', () => this.onWindowResize());
            }

            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                // Directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);

                // Fill light
                const fillLight = new THREE.DirectionalLight(0xC9A460, 0.3);
                fillLight.position.set(-5, 5, -5);
                this.scene.add(fillLight);
            }

            async loadAvatar() {
                try {
                    const loader = new THREE.GLTFLoader();
                    
                    // Load the main avatar model
                    const gltf = await new Promise((resolve, reject) => {
                        loader.load('../assets/models/modelguy.glb', resolve, undefined, reject);
                    });

                    this.avatar = gltf.scene;
                    this.avatar.position.set(0, 0, 0);
                    this.avatar.scale.set(1, 1, 1);
                    
                    // Enable shadows
                    this.avatar.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    this.scene.add(this.avatar);

                    // Setup animation mixer
                    this.mixer = new THREE.AnimationMixer(this.avatar);
                    
                    // Load animations if available in GLTF
                    if (gltf.animations && gltf.animations.length > 0) {
                        gltf.animations.forEach((clip) => {
                            this.animations[clip.name] = this.mixer.clipAction(clip);
                        });
                    }

                    // Load additional FBX animations
                    await this.loadFBXAnimations();

                    // Start with idle animation
                    this.playAnimation('idle');

                    document.getElementById('loading').style.display = 'none';
                    console.log('âœ… Siraj Avatar loaded successfully');

                } catch (error) {
                    console.error('âŒ Failed to load avatar:', error);
                    document.getElementById('loading').innerHTML = 'Failed to load avatar';
                }
            }

            async loadFBXAnimations() {
                const fbxLoader = new THREE.FBXLoader();
                const animationFiles = [
                    'StandingIdle',
                    'Talking_0',
                    'Talking_1', 
                    'Talking_2',
                    'Angry',
                    'Crying',
                    'Laughing',
                    'Terrified'
                ];

                for (const animName of animationFiles) {
                    try {
                        const fbx = await new Promise((resolve, reject) => {
                            fbxLoader.load(`../assets/animations/${animName}.fbx`, resolve, undefined, reject);
                        });

                        if (fbx.animations && fbx.animations.length > 0) {
                            const action = this.mixer.clipAction(fbx.animations[0]);
                            this.animations[animName.toLowerCase()] = action;
                        }
                    } catch (error) {
                        console.warn(`âš ï¸ Could not load animation: ${animName}`, error);
                    }
                }
            }

            playAnimation(animationName, loop = true) {
                if (this.currentAnimation) {
                    this.currentAnimation.fadeOut(0.3);
                }

                const animation = this.animations[animationName.toLowerCase()];
                if (animation) {
                    animation.reset();
                    animation.fadeIn(0.3);
                    animation.setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce);
                    animation.play();
                    this.currentAnimation = animation;
                }
            }

            setEmotion(emotion) {
                this.currentEmotion = emotion;
                
                // Map emotions to animations
                const emotionAnimations = {
                    'happy': 'laughing',
                    'sad': 'crying',
                    'angry': 'angry',
                    'fear': 'terrified',
                    'neutral': 'standingidle',
                    'talking': 'talking_1'
                };

                const animationName = emotionAnimations[emotion] || 'standingidle';
                this.playAnimation(animationName);

                // Update emotion indicator
                const emotionIndicator = document.getElementById('emotion-indicator');
                const emotionEmojis = {
                    'happy': 'ðŸ˜Š',
                    'sad': 'ðŸ˜¢',
                    'angry': 'ðŸ˜ ',
                    'fear': 'ðŸ˜¨',
                    'neutral': 'ðŸ˜',
                    'talking': 'ðŸ—£ï¸'
                };

                emotionIndicator.innerHTML = `${emotionEmojis[emotion] || 'ðŸ˜'} ${emotion.charAt(0).toUpperCase() + emotion.slice(1)}`;
                emotionIndicator.style.display = 'block';
            }

            startLipSync(lipSyncData) {
                this.lipSyncData = lipSyncData;
                this.lipSyncStartTime = Date.now();
                this.isPlaying = true;
                this.setEmotion('talking');
            }

            updateLipSync() {
                if (!this.lipSyncData || !this.isPlaying) return;

                const currentTime = (Date.now() - this.lipSyncStartTime) / 1000;
                
                // Find current mouth shape based on time
                if (this.lipSyncData.mouthCues) {
                    for (const cue of this.lipSyncData.mouthCues) {
                        if (currentTime >= cue.start && currentTime <= cue.end) {
                            this.setMouthShape(cue.value);
                            break;
                        }
                    }
                }

                // Check if lip sync is finished
                const duration = this.lipSyncData.metadata?.duration || 5;
                if (currentTime > duration) {
                    this.stopLipSync();
                }
            }

            setMouthShape(shape) {
                // This would control mouth morphing based on phonemes
                // For now, we'll use different talking animations
                const talkingAnimations = ['talking_0', 'talking_1', 'talking_2'];
                const randomTalking = talkingAnimations[Math.floor(Math.random() * talkingAnimations.length)];
                
                if (Math.random() > 0.7) { // Change animation occasionally
                    this.playAnimation(randomTalking, false);
                }
            }

            stopLipSync() {
                this.isPlaying = false;
                this.lipSyncData = null;
                this.setEmotion('neutral');
            }

            setupMessageListener() {
                window.addEventListener('message', (event) => {
                    const { type, data } = event.data;
                    
                    switch (type) {
                        case 'setEmotion':
                            this.setEmotion(data.emotion);
                            break;
                        case 'startLipSync':
                            this.startLipSync(data.lipSyncData);
                            break;
                        case 'stopLipSync':
                            this.stopLipSync();
                            break;
                        case 'playAnimation':
                            this.playAnimation(data.animation, data.loop);
                            break;
                    }
                });

                // Notify Flutter that avatar is ready
                window.parent.postMessage({ type: 'avatarReady' }, '*');
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // Update controls
                this.controls.update();

                // Update animations
                if (this.mixer) {
                    this.mixer.update(0.016); // 60 FPS
                }

                // Update lip sync
                this.updateLipSync();

                // Render
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize avatar when page loads
        window.addEventListener('load', () => {
            new SirajAvatar();
        });
    </script>
</body>
</html>

